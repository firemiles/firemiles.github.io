<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>linux - 标签 - firemiles 的个人博客</title><link>https://blog.firemiles.top/tags/linux/</link><description>linux - 标签 - firemiles 的个人博客</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>miles.dev@outlook.comm (firemiles)</managingEditor><webMaster>miles.dev@outlook.comm (firemiles)</webMaster><lastBuildDate>Sun, 22 May 2022 08:00:00 +0000</lastBuildDate><atom:link href="https://blog.firemiles.top/tags/linux/" rel="self" type="application/rss+xml"/><item><title>cgroup v2学习</title><link>https://blog.firemiles.top/2022/cgroupv2%E5%AD%A6%E4%B9%A0/</link><pubDate>Sun, 22 May 2022 08:00:00 +0000</pubDate><author>firemiles</author><guid>https://blog.firemiles.top/2022/cgroupv2%E5%AD%A6%E4%B9%A0/</guid><description><![CDATA[<h2 id="前言">前言</h2>
<p>这几年工作重心一直在容器网络方向，对虚拟化技术，容器隔离技术一直处于一知半解的状态，但是心里一直有着好奇，到底是怎样的技术，构建出了如今的容器化技术世界。项目中用到了cgroupV2，正好最近有时间，直接跳过cgroupV1学习了下cgroupV2的文档，这里分享内容主要来自<a href="https://arthurchiao.art/blog/cgroupv2-zh/" target="_blank" rel="noopener noreffer">官方权威文档中文翻译</a>。</p>
<h2 id="什么是cgroup">什么是cgroup</h2>
<p><code>cgroup</code> 是 &ldquo;control group&rdquo; 的缩写，并且首字母永远不大写。<code>cgroup</code> 是一种以 hierarchical (树形层级)方式组织进程的机制，以及在层级中以受控和可配置的方式分发系统资源。</p>
<ul>
<li>单数形式（cgroup）指这个特性，或用户 &ldquo;cgroup controllers&rdquo; 等术语中的修饰词</li>
<li>复数形式（cgroups） 显式地指多个cgroup</li>
</ul>
<p>cgroup 是 Linux 内核的一个功能，用来限制、控制与分离一个进程组的资源（如CPU、内存、磁盘输入输出等）。它最早由Google的工程师（主要是Paul Menage和Rohit Seth）在2006年发起，最早名称为进程容器（process containers）。在2007年时，因为在Linux内核中，容器（container）这个名词有许多不同的意义，为避免混乱，被重新命名为cgroup，并且被合并到2.6.24版的内核中去。</p>
<p>cgroups的一个设计目标是为不同的应用情况提供统一的接口，从控制单一进程（像nice）到作业系统层虚拟化（像OpenVZ，Linux-VServer，LXC）。cgroups 提供：</p>
<ul>
<li>资源限制：组可以被设置不超过设定的内存限制，包括虚拟内存。</li>
<li>优先级：一些组可能会得到大量的CPU或磁盘IO吞吐量。</li>
<li>结算：用来度量系统实际用了多少资源。</li>
<li>控制：冻结组或检查点和重启动。</li>
</ul>
<p>cgroup 主要由两部分组成：</p>
<ol>
<li><code>核心（core）</code>：主要负责层级化地组织进程；</li>
<li><code>控制器（controllers）</code>：大部分控制器负责cgroup层级中特定类型的系统资源分配，少部分utility控制器用于其他目的。</li>
</ol>
<h2 id="为什么会有cgroup">为什么会有cgroup</h2>
<p>在 Linux 里，一直依赖就有对进程进行分组的概念和需求，比如 <code>session group</code>, <code>progress group</code> 等，后来随着人们对这方面的需求越来越多，比如需要追踪一组进程的内存和IO 使用情况等，于是出现了cgroup，用来统一将进程进行分组，并在分组的基础上对进程进行监控和资源控制管理等。</p>
<p>在 <code>CentOS 7</code> 中，通过将cgroup层级系统与systemd单位树捆绑， 可以把资源管理设置从进程级别移至应用程序级别。默认情况下，systemd 会自动创建 <code>slice</code>、<code>scope</code>和<code>service</code>单位的层级，来为 cgroup 树提供统一结构，可以通过 <code>systemctl</code> 命令创建自定义slice进一步修改结构。</p>
<p></p>
<p>如上图所示，系统默认创建了3个顶级<code>slice</code>(<code>System</code>,<code>User</code>和<code>Machine</code>)。每个slice都会获得相同CPU使用时间，如果<code>user.slice</code>想要获得<code>100%</code>的CPU使用时间，而此时CPU比较空闲，那么<code>user.slice</code>就能如愿以偿。</p>
<h2 id="为什么会有cgroupv2">为什么会有cgroupV2</h2>
<p>cgroup v1 支持多个 hierarchy，每个hierarchy可以启用任意数量的controller。这种方式看上去高度灵活，但实际中并不是很有用。例如：</p>
<ol>
<li>utility 类型的 controller（例如freezer）本可用与多个hierarchy，而由于v1中每个controller只有一个实例，utility controller的作用就大打折扣；而hierarchy 一旦被populated之后，控制器就不能移动到其他hierarchy的事实，更是加剧了这个问题。</li>
<li>另一个问题是，关联到某个hierarchy的所有控制器，只能拥有相同的hierarchy视图。无法在controller粒度改变这种视图。</li>
</ol>
<p></p>
<p>在实际中，大部分hierarhchy都启动了所有控制器，而实际上只有联系非常紧密的控制器——例如cpu和cpuacct放到同一个hierarchy中才有意义。最终结果是：</p>
<ol>
<li>用户控件最后管理这多个非常类似的hierarchy</li>
<li>在执行hierarchy管理操作是，每个hierarchy上重复着相同的操作。</li>
</ol>
<h3 id="其他-cgroup-接口相关问题">其他 cgroup 接口相关问题</h3>
<p>v1的设计并没有前瞻性，因此后面引入了大量怪异特性和不一致性。</p>
<h2 id="cgroupv2的功能">cgroupV2的功能</h2>
<p>cgroup v2将多个hierarchy的方式变成了 unified hierarchy，并将所有的controller挂载到一个unified hierarchy。</p>
<p>当前kernel没有一处 cgroup v1版本，允许cgroup v1和v2共存，但是相同的controller不能同时mount到这两个不同的cgroup版本中。</p>
<blockquote>
<p>进程能否是同时属于cgroup v1和cgroup v2？可以的，查看 <code>/proc/$PID/cgroup</code> 会返现同时包含v1和v2 membership</p>
</blockquote>
<h3 id="进程线程与-cgroup-关系">进程/线程与 cgroup 关系</h3>
<p>所有cgroup组成一个树形结构。</p>
<ul>
<li>系统中的每个进程都属于且只属于某一个cgroup；</li>
<li>一个进程的所有线程属于同一个cgroup；</li>
<li>创建子进程时，继承其父进程的cgroup；</li>
<li>一个进程可以迁移到其他cgroup；</li>
<li>迁移一个进程时，子进程（后台进程）不会自动跟着一起迁移；</li>
</ul>
<h3 id="控制器">控制器</h3>
<p>可以选择性地针对一个cgroup启用或禁用某些控制器；</p>
<p>控制器的所有行为是hierarchical的。</p>
<ul>
<li>如果一个cgroup启用了某个控制器，它的sub-hierarchy中所有进程都会受控制</li>
<li>如果在更接近的root的节点上设置了资源限制，那下面的sub-hierarchy是无法覆盖也，也就是sub-hierarchy受parent限制。</li>
</ul>
<h3 id="基础操作">基础操作</h3>
<h4 id="挂载">挂载</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mount -t cgroup2 none <span class="nv">$MOUNT_POINT</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>cgroupv2 文件系统的magic number是<code>0x63677270</code>（&ldquo;cgrp&rdquo;）</p>
<ul>
<li>所有支持v2且未绑定到v1的控制器，会被自动绑定到v2的hierarchy，出现在root层级中。</li>
<li>v2中未使用的控制器也可以绑定到其他的hierarchies。</li>
</ul>
<p>这说明我们能以完全向后兼容的方式混用v2和v1 hierarchy。</p>
<h3 id="组织进程和线程">组织进程和线程</h3>
<h4 id="进程创建删除移动查看-cgroup">进程：创建/删除/移动/查看 cgroup</h4>
<p>初始状态下，只有root cgroup，所有进程都属于这个cgroup。</p>
<ul>
<li>创建sub-cgroup：只需要创建一个子目录
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">mkdir <span class="nv">$CGROUP_NAME</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<ul>
<li>
<p>将进程移动到指定cgroup：将PID写入到相应cgroup的cgroup.procs文件即可。</p>
<ul>
<li>每次<code>write(2)</code>只能迁移一个进程</li>
<li>如果进程有多个线程，那将任意线程PID写入到文件，都会将该进程的所有线程迁移到相应的cgroup。</li>
<li>如果进程fork出一个子进程，那子进程属于执行fork操作时父进程所属的cgroup。</li>
<li>进程退出（exit）后，仍然留在退出时它所属的cgroup，直到这个进程被收割（reap）；</li>
<li>僵尸进程不会出现在cgroup.procs中，因此无法对僵尸进程执行迁移操作。</li>
</ul>
</li>
<li>
<p>删除cgroup/sub-cgroup</p>
<ul>
<li>如果一个cgroup 已经没有任何children或活进程，那直接删除对应的文件夹就删除该cgroup了</li>
<li>如果一个cgroup已经没有children，但是还有僵尸进程，也认为这个cgroup是空的，可以直接删除</li>
</ul>
</li>
<li>
<p>查看进程的cgroup信息：<code>cat /proc/$PID/cgroup</code> 会列出该进程的 cgroup membership。如果启用了v1，这个文件可能会包含多行，每个hierarchy一行。v2对应的行永远是0::$PATH格式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">$ cat /proc/<span class="nv">$$</span>/cgroup <span class="c1"># ubuntu 20.04 上的输出，$$ 是当前 shell 的进程 ID</span>
</span></span><span class="line"><span class="cl">12:devices:/user.slice
</span></span><span class="line"><span class="cl">11:freezer:/
</span></span><span class="line"><span class="cl">10:memory:/user.slice/user-1000.slice/session-1.scope
</span></span><span class="line"><span class="cl">9:hugetlb:/
</span></span><span class="line"><span class="cl">8:cpuset:/
</span></span><span class="line"><span class="cl">7:perf_event:/
</span></span><span class="line"><span class="cl">6:rdma:/
</span></span><span class="line"><span class="cl">5:pids:/user.slice/user-1000.slice/session-1.scope
</span></span><span class="line"><span class="cl">4:cpu,cpuacct:/user.slice
</span></span><span class="line"><span class="cl">3:blkio:/user.slice
</span></span><span class="line"><span class="cl">2:net_cls,net_prio:/
</span></span><span class="line"><span class="cl">1:name<span class="o">=</span>systemd:/user.slice/user-1000.slice/session-1.scope
</span></span><span class="line"><span class="cl">0::/user.slice/user-1000.slice/session-1.scope  <span class="c1"># v2</span>
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h4 id="线程">线程</h4>
<ul>
<li>cgroup v2 的一部分控制器支持线程粒度的资源控制，这种控制器称为threaded controllers。
<ul>
<li>默认情况下，一个进程的所有线程属于同一个cgroup，</li>
<li>线程模型使我们能将不同线程放到subtree的不同位置，同时还能保持二者在同一个资源域（resource domain）内。</li>
</ul>
</li>
<li>不支持线程模型的控制器称为domain controllers。</li>
</ul>
<p>将cgroup改成threaded模式（单向/不可逆操作）
cgroup 创建之后都是domain cgroup，可以通过下面的命令将其改成threaded模式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="nb">echo</span> threaded &gt; cgroup.type
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="控制器-1">控制器</h3>
<ul>
<li>CPU</li>
<li>Memory</li>
<li>IO</li>
<li>PID</li>
<li>Cpuset</li>
<li>Device Controller（基于cgroup BPF）</li>
<li>RDMA</li>
<li>HugeTLB</li>
<li>Misc
<ul>
<li>perf_event</li>
</ul>
</li>
</ul>
<h3 id="cgroup-命名控件cgroupns">cgroup 命名控件（cgroupns）</h3>
<p>容器环境中用cgroup和其他一些namespace来隔离进程，但是<code>/proc/$PID/cgroup</code> 文件可能会泄露潜在的系统层信息。例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">cat /proc/self/cgroup
</span></span><span class="line"><span class="cl">0::/batchjobs/container_id1 <span class="c1"># &lt;-- cgroup 的绝对路径，属于系统层信息，不希望暴露给隔离的进程</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因此引入了cgroup namespace。</p>
<h2 id="cgroupv2的实现">cgroupV2的实现</h2>
<h3 id="cgroup-控制接口">cgroup 控制接口</h3>
<p>
Linux 使用了多种数据结构在内核中实现了cgroups的配置，关联了进程和cgroups节点，那么Linux又是如何让用户态进程使用cgroups的功能呢？Linux内核有一个很大的模块叫VFS（Virtual File System）。VFS能够把具体的文件系统细节隐藏起来，给用户态进程提供一个同一个为文件系统API接口。cgrpus与CFS之间衔接的部分称之为cgroup文件系统。</p>
<h2 id="cgroupv2的典型应用">cgroupV2的典型应用</h2>
<p>听说cgroup是从docker开始，也是容器技术带火了cgroup技术，这里简单介绍下容器如何使用cgroup。</p>
<p></p>
<p></p>
<p></p>

<div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
  <iframe src="https://www.youtube-nocookie.com/embed/u8h0e84HxcE" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" allowfullscreen title="YouTube Video"></iframe>
</div>

<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://www.wikiwand.com/zh-hans/Cgroups" target="_blank" rel="noopener noreffer">https://www.wikiwand.com/zh-hans/Cgroups</a></li>
<li><a href="https://arthurchiao.art/blog/cgroupv2-zh/" target="_blank" rel="noopener noreffer">https://arthurchiao.art/blog/cgroupv2-zh/</a></li>
<li><a href="https://segmentfault.com/a/1190000040980305" target="_blank" rel="noopener noreffer">https://segmentfault.com/a/1190000040980305</a></li>
<li><a href="https://juejin.cn/post/6844904110639054861" target="_blank" rel="noopener noreffer">https://juejin.cn/post/6844904110639054861</a></li>
</ul>
]]></description></item><item><title>WSL2安装内核头文件</title><link>https://blog.firemiles.top/2022/wsl2%E5%AE%89%E8%A3%85%E5%86%85%E6%A0%B8%E5%A4%B4%E6%96%87%E4%BB%B6/</link><pubDate>Sat, 23 Apr 2022 20:36:23 +0000</pubDate><author>firemiles</author><guid>https://blog.firemiles.top/2022/wsl2%E5%AE%89%E8%A3%85%E5%86%85%E6%A0%B8%E5%A4%B4%E6%96%87%E4%BB%B6/</guid><description><![CDATA[<h2 id="前言">前言</h2>
<p>一般 Linux 的发行版直接使用软件源就可以安装内核模块和内核头文件，但是WSL2作为一个特殊的版本，
大部分内核模块无法安装，也无法直接安装内核头文件，还有部分依赖内核头文件的工具也无法运行，本文主要介绍内核头文件的安装。</p>
<h2 id="安装">安装</h2>
<ul>
<li>
<p>第一步先去github上下载WSL2内核源码，仓库在 <a href="https://github.com/microsoft/WSL2-Linux-Kernel" target="_blank" rel="noopener noreffer">https://github.com/microsoft/WSL2-Linux-Kernel</a> 。下载当前运行的内核版本。这里以<code>4.19.121</code>为例</p>
</li>
<li>
<p>开始安装依赖</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">apt install libelf-dev build-essential pkg-config
</span></span><span class="line"><span class="cl">apt install bison build-essential flex libssl-dev libelf-dev bc
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>编译</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">tar -zvxf 4.19.121-microsoft-standard.tar.gz
</span></span><span class="line"><span class="cl"><span class="nb">cd</span> WSL2-Linux-Kernel-4.19.121-microsoft-standard.tar.gz
</span></span><span class="line"><span class="cl">zcat /proc/config.gz &gt; .config
</span></span><span class="line"><span class="cl">make -j <span class="k">$(</span>nproc<span class="k">)</span>
</span></span><span class="line"><span class="cl">make -j <span class="k">$(</span>nproc<span class="k">)</span> modules_install
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>编译过程中可能会出现一些报错，一般是还缺少部分依赖，通过Google可以找到解决办法。</p>
</blockquote>
<p>编译完成后，在 /lib/modules/ 会出现 4.19.121-microsoft-standard 目录，头文件就可以使用了，借助头文件，其他的内核模块也可以自行编译安装。</p>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://mashiro01.github.io/2020/08/24/wsl2%E4%B8%8B%E5%86%85%E6%A0%B8%E5%A4%B4%E6%96%87%E4%BB%B6/" target="_blank" rel="noopener noreffer">WSL2 下的 kernel header 的安装</a></li>
</ul>
]]></description></item><item><title>LDD阅读笔记之字符设备驱动</title><link>https://blog.firemiles.top/2015/ldd%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</link><pubDate>Sun, 04 Jan 2015 09:23:20 +0000</pubDate><author>firemiles</author><guid>https://blog.firemiles.top/2015/ldd%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%E4%B9%8B%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/</guid><description><![CDATA[<h1 id="主要开发流程介绍">主要开发流程介绍</h1>
<p>module_init宏和module_exit宏</p>
<pre><code>当模块装载时需要调用module_init宏指定的函数，
卸载时需要调用 module_exit宏指定的函数
</code></pre>
<p>以下是简单的init流程：</p>
<ul>
<li>初始化设备</li>
<li>初始化file_operation</li>
<li>获取字符设备号</li>
<li>注册字符设备</li>
</ul>
<p>当卸载模块时，需要释放申请的设备号。</p>
<h1 id="主设备号和次设备号">主设备号和次设备号</h1>
<p>对字符设备的访问是通过文件系统内的设备名称进行的。那些名称被称为特殊 文件、设备文件，或者简单称为文件系统树的节点，他们通常位于/dev目录。</p>
<p>通常而言，主设备号表示设备对应的驱动程序。例如，/dev/null和/dev/zero 由驱动程序1管理，而虚拟控制台和串口终端由驱动程序4管理。</p>
<blockquote>
<p>现代的Linux内核允许多个驱动程序共享主设备号，但我们看到的仍然按照”一个主设备号对应一个驱动程序“的原则组织。次设备号的作用被加强了，一个主设备号加一个次设备号可以对应一个驱动程序。</p>
</blockquote>
<blockquote>
<p>/proc/devices 可以查看注册的主设备号；/proc/modules 可以查看正在使用模块的进程数两个文件中的module名字不同，devices中的是用户设置的name，modules中的是名字module.ko中的module。</p>
</blockquote>
<h1 id="设备编号的内部表达">设备编号的内部表达</h1>
<p>在内核中dev_t类型（在linux/types.h中定义）用来保存设备编号——包括主设备号和次设备号。我们的代码不应该对设备编号的组织做任何假定，而应该始终使用linux/kdev_t.h中定义的宏。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">MAJOR</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">dev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">MINOR</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">dev</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>相反，如果要将主设备号和次设备号转换成dev_t类型，则使用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">MKDEV</span><span class="p">(</span><span class="kt">int</span> <span class="n">major</span><span class="p">,</span> <span class="kt">int</span> <span class="n">minor</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="分配和释放设备编号">分配和释放设备编号</h1>
<p>在建立一个字符设备之前，我们的驱动程序首先要做的事情就是获得一个或者多个设备编号。完成该工作的必要函数是 <em>register_chrdev_region</em>，该函数在linux/fd.h中声明：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">register_chrdev_region</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">first</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中 <em>first</em> 是要分配的设备编号范围的起始值。first的次设备号经常被置为0，但对该函数不是必须的。<em>count</em> 是所请求的连续设备编号的个数。 <em>name</em> 是和该编号范围关联的设备名称，它将出现在/proc/devices和sysfs中。</p>
<p>如果我们知道可用的设备编号，则 <em>register_chrdev_region</em> 会工作很好。但是 我们进程不知道将要用哪些主设备号；应此提供了以下函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">alloc_chrdev_region</span><span class="p">(</span><span class="n">dev_t</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">firstminor</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>dev</em> 用于输出参数，成功调用后保存已分配范围的第一个编号。 <em>firstminor</em> 应该是 要使用的被请求的第一个次设备号，通常是0。 <em>count</em> 和 <em>name</em> 参数和 <em>register_chrdev_region</em> 相同。</p>
<p>无论使用哪种方法分配设备号，都应该在不再使用它们时释放这些设备编号。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">unregister_chrdev_region</span><span class="p">(</span><span class="n">dev_t</span> <span class="n">first</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通常我们在清除模块中调用 <em>unregister_chrdev_region</em> 函数。</p>
<h1 id="一些重要的数据结构">一些重要的数据结构</h1>
<h2 id="文件操作">文件操作</h2>
<p>迄今为止，我们已经为自己保留了一些设备编号，但尚未将任何驱动程序的操作连接到这些 编号。file_operations结构就是用来建立这种连接的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">file_operations</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">     <span class="n">loff_t</span><span class="p">(</span><span class="o">*</span><span class="n">llseek</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="n">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">read</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="n">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">aio_read</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span> <span class="n">loff_t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="n">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">write</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="n">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">aio_write</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                  <span class="n">loff_t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">readdir</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="n">filldir_t</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="nf">int</span> <span class="p">(</span><span class="o">*</span><span class="n">poll</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">poll_table_struct</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ioctl</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">mmap</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">flush</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fsync</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">aio_fsync</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">fasync</span><span class="p">)</span> <span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="n">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">readv</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">              <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="n">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">writev</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">               <span class="n">loff_t</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="n">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">sendfile</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span> <span class="n">read_actor_t</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">     <span class="n">ssize_t</span><span class="p">(</span><span class="o">*</span><span class="n">sendpage</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">size_t</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                 <span class="n">loff_t</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="nf">long</span> <span class="p">(</span><span class="o">*</span><span class="n">get_unmapped_area</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">file_operations</span> <span class="n">scull_fops</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">scull_llseek</span><span class="p">,</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span> <span class="c1">//C99 syntax
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="file结构">file结构</h2>
<p>在linux/fs.h中定义的struct file是设备驱动程序所使用的第二个最重要的数据结构。</p>
<blockquote>
<p>注意：file结构和用户空间程序中的FILE没有任何关联。FILE是C库中的定义的结构， 而struct file是一个内核结构，不会出现在用户程序中（文件描述符应该是指向该结构体）。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">file</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">mode_t</span> <span class="n">f_mode</span><span class="p">;</span>      <span class="c1">//文件模式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">loff_t</span> <span class="n">f_pos</span><span class="p">;</span>       <span class="c1">//当前读写位置
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f_flags</span><span class="p">;</span> <span class="c1">//文件标志，如O_RDONLY、O_NONBLOCK和O_SYNC。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">f_op</span><span class="p">;</span>   <span class="c1">//与文件相关的操作。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">void</span> <span class="o">*</span><span class="n">private_data</span><span class="p">;</span>     <span class="c1">//open系统调用在调用驱动程序的open方法前将这个
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                            <span class="c1">//指针置为NULL。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">f_dentry</span><span class="p">;</span><span class="c1">//文件对应的目录项(dentry)结构。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                            <span class="c1">//filp-&gt;f_dentry-&gt;d_inode
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">……</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="inode结构">inode结构</h2>
<p>内核用inode结构在内部表示文件，因此它和file结构不同，后者表示打开的文件描述符。对 单个文件，可能会有多个表示打开的文件描述符的file结构，但它们都指向单个inode结构。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">inode</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">dev_t</span> <span class="n">i_rdev</span><span class="p">;</span>       <span class="c1">//对表示设备文件的inode结构，
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                        <span class="c1">//该字段包含了真正的设备编号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">struct</span> <span class="n">cdev</span> <span class="o">*</span><span class="n">i_cdev</span><span class="p">;</span><span class="c1">//表示字符设备的内核内部结构。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="err">……</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>i_rdev</em> 的类型在2.5开发系列版本中发生了变化，为了鼓励编写可移植性更强的代码， 内核开发者增加了两个新的宏。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">iminor</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>       <span class="c1">//获取次设备号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">imajor</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>       <span class="c1">//获取主设备号
</span></span></span></code></pre></td></tr></table>
</div>
</div><h1 id="字符设备的注册">字符设备的注册</h1>
<p>内核内部使用struct cdev结构来表示字符设备。在内核调用设备的操作之前，必须分配 并注册一个或者多个上述结构。为此，我们的代码需要包含linux/cdev.h，其中定义 了这个结构以及与其相关的一些辅助函数。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">cdev</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">kobject</span> <span class="n">kobj</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">module</span> <span class="o">*</span><span class="n">owner</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">dev_t</span> <span class="n">dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>有一个老的机制可以避免使用cdev结构，但是新代码应该使用新技术。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">cdev</span> <span class="o">*</span><span class="n">my_cdev</span> <span class="o">=</span> <span class="n">cdev_alloc</span><span class="p">();</span>
</span></span><span class="line"><span class="cl"><span class="n">my_cdev</span><span class="o">-&gt;</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">my_fops</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们可以将cdev结构嵌入到自己的设备特定结构中（有点类似派生的C版本）。 如果没有通过 <em>cdev_alloc</em> 申请，则我们需要用下面的代码来初始化已分配的结构：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span>  <span class="nf">cdev_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">cdev</span> <span class="o">*</span><span class="n">cdev</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                    <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>还有一个字段需要初始化，和file_operations一样，struct cdev也有一个所有者字段， 应设置为THIS_MODULE。</p>
<p>在设置完cdev结构后，最后的步骤是告诉内核该结构的信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">cdev_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">cdev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">num</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">            <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><em>num</em> 是该设备对应的第一个设备编号，count是应该和该设备关联的设备编号数量。 只要 <em>cdev_add</em> 成功返回，我们的设备就要开始工作了，它的操作会被内核调用。 要从系统移除一个字符设备，做如下调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">cdev_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">cdev</span> <span class="o">*</span><span class="n">dev</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在将cdev通过 <em>cdev_del</em> 移除后，就不应该再访问cdev结构了。</p>
<h2 id="scull中的设备注册">Scull中的设备注册</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">scull_setup_cdev</span><span class="p">(</span><span class="k">struct</span> <span class="n">scull_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">devno</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">scull_major</span><span class="p">,</span> <span class="n">scull_minor</span><span class="o">+</span><span class="n">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">cdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scull_fops</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">scull_fops</span><span class="p">;</span>  <span class="c1">// this expression is redundancy ?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">err</span> <span class="o">=</span> <span class="n">cdev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">,</span> <span class="n">devno</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">err</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&#34;Error %d adding scull%d&#34;</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为cdev结构被内嵌到了strcut scull_dev中，因此必须调用cdev_init来执行该结构的初始化。</p>
<h2 id="早期办法">早期办法</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">register_chrdev</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">major</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                        <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">fops</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>对 <em>register_chrdev</em> 的调用将为 <strong>给定的主设备号注册0～255作为次设备号</strong>，并为 每个设备建立一个对应的默认cdev结构。使用这一接口的驱动程序必须能够处理所有 256个次设备号上的 <em>open</em> 调用。对应的移除函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">unregister_chrdev</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">major</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="open和release">open和release</h1>
<h2 id="open方法">open方法</h2>
<p><em>open</em> 方法提供给驱动程序以初始化的能力（和module_init的不同），open应完成如下 工作：</p>
<ul>
<li>检查设备特定的错误（如设备未就绪或类似硬件问题）</li>
<li>如果设备首次打开，对其进行初始化。</li>
<li>如有必要，更新f_op指针。</li>
<li>分配并填写置于filp-&gt;private_data里的数据结构。</li>
</ul>
<p><em>open</em> 方法的原型如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">open</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>inode参数在i_cdev字段中包含了我们需要的信息，即我们先前设定的cdev结构。我们通常需要 包含它的scull_dev结构，内核黑客为我们提供了此类技巧，它通过定义在linux/kernel.h 中的container_of宏实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">container_of</span><span class="p">(</span><span class="n">pointer</span><span class="p">,</span> <span class="n">container_type</span><span class="p">,</span> <span class="n">container_field</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">scull_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_cdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scull_dev</span><span class="p">,</span> <span class="n">cdev</span><span class="p">);</span> <span class="c1">//cdev是成员名
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">flip</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>另一个确定要打开的设备的方法是：检查保存在inode中的次设备号。如果使用了 <em>register_chrdev</em> 注册设备，则必须使用该技术。 经过简化的 <em>scull_open</em> 代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">scull_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">scutll_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_cdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scull_dev</span><span class="p">,</span> <span class="n">cdev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">((</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="o">&amp;</span><span class="n">O_ACCMODE</span><span class="p">)</span><span class="o">==</span><span class="n">O_WRONLY</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">        <span class="n">scull_trim</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>由于我们没有维护scull的打开计数，只维护模块的使用计数，因此也就没有类似&quot;首次打开时初始化设备&quot;这类动作。</p>
<h2 id="release方法">release方法</h2>
<p><em>release</em> 方法和 <em>open</em> 相反，有时这个方法被称为 <em>device_close</em>。</p>
<ul>
<li>释放由 <em>open</em> 分配的、保存在filp-&gt;private_data中的所有内容。</li>
<li>在最后一次关闭操作时关闭设备。</li>
</ul>
<blockquote>
<p>注： 后面scull_open为每种设备都替换了不同的filp-&gt;f_op，所以不同的设备由 不同的函数关闭</p>
</blockquote>
<p>当关闭一个设备文件的次数比打开它的次数多时，系统中会发生什么？ 答案很简单：并不是每个close系统调用都会引起对release方法的调用。只有 真正释放设备数据结构的 <em>close</em> 调用才会调用这个方法。内核对每个file 结构维护其被使用多少次的计数器。无论 <em>fork</em> 还是 <em>dup</em> 都不会创建新 的数据结构（仅由open创建），他们只是增加已有结构中的计数。只有file结 构的计数归零是，close系统调用才会执行release方法，这只在删除这个结 构时才会发生。<strong>保证了一次open只会看到一次release调用</strong>。</p>
<blockquote>
<p>注意：flush方法在应用程序每次调用close时都会调用。</p>
</blockquote>
<h1 id="read和write">read和write</h1>
<p><em>read</em> 和 <em>write</em> 方法完成的任务是相似的，亦即，拷贝数据到应用程序空间， 或者反过来。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-C" data-lang="C"><span class="line"><span class="cl"><span class="n">ssize_t</span> <span class="nf">read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ssize_t</span> <span class="nf">write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">            <span class="n">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offp</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要说明的是read和write方法的buff参数是用户空间的指针。因此，代码不能直接 引用其中内容。原因如下：</p>
<ul>
<li>随着驱动程序所运行的架构不同或者内核配置不同，在内核模式运行时，用户
空间的指针可能是无效的。</li>
<li>即使该指针在内核空间中代表相同的东西，但用户空间的内存是分页的，而在系统
调用被调用时，涉及到的内存可能根本不在RAM中。对用户空间的内存的直接引用
将导致页错误，而这对内核代码来说是不允许发生的事情。其结果可能是“oops”。</li>
<li>我们讨论的指针可能由用户程序提供，而该程序可能存在缺陷或者是个恶意程序。</li>
</ul>
<p>为确保安全，需要使用下面几个函数（由linux/uaccess.h中定义）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">copy_to_user</span><span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                            <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">copy_from_user</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">from</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                             <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当内核空间运行的代码访问用户空间的时候必须多加小心，因为被寻址的用户页面 可能不存在当前内存中，于是虚拟内存子系统经该进程转入休眠，知道该页面被加载 到期望位置。对驱动开发人员来说，这带来的结果就是任何访问用户空间的函数都是 必须可重入的（异步信号安全），必须能和其他驱动程序函数并发执行，更特别的是 必须处于能够合法休眠的状态。</p>
<p></p>
<h1 id="readv和writev">readv和writev</h1>
<p>Unix系统很早就已支持两个可选的系统调用：readv和writev。 如果驱动程序没有提供用于处理向量操作的方法，readv和writev会通过对read和 write方法的多次调用来实现。但在很多情况下，直接在驱动程序中实现readv和writev 可以获得更高的效率。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">readv</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="n">ssize_t</span> <span class="p">(</span><span class="o">*</span><span class="n">writev</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">                    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>iovec结构定义在linux/uio.h中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">iovec</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">iov_base</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">__kernel_size_t</span> <span class="n">iov_len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个iovec结构都描述了一个用于传输的数据块。函数中的count参数指明要操作多少 个iovec结构。 正确而有效率的操作经常需要驱动程序做一些更为巧妙的事情。 例如，磁带驱动程序的writev就应将所有iovec结构的内容作为磁带上的单个记录写入。 如果忽略他们，内核会通过read和write模拟它们。</p>
<h1 id="实例">实例</h1>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span><span class="lnt">149
</span><span class="lnt">150
</span><span class="lnt">151
</span><span class="lnt">152
</span><span class="lnt">153
</span><span class="lnt">154
</span><span class="lnt">155
</span><span class="lnt">156
</span><span class="lnt">157
</span><span class="lnt">158
</span><span class="lnt">159
</span><span class="lnt">160
</span><span class="lnt">161
</span><span class="lnt">162
</span><span class="lnt">163
</span><span class="lnt">164
</span><span class="lnt">165
</span><span class="lnt">166
</span><span class="lnt">167
</span><span class="lnt">168
</span><span class="lnt">169
</span><span class="lnt">170
</span><span class="lnt">171
</span><span class="lnt">172
</span><span class="lnt">173
</span><span class="lnt">174
</span><span class="lnt">175
</span><span class="lnt">176
</span><span class="lnt">177
</span><span class="lnt">178
</span><span class="lnt">179
</span><span class="lnt">180
</span><span class="lnt">181
</span><span class="lnt">182
</span><span class="lnt">183
</span><span class="lnt">184
</span><span class="lnt">185
</span><span class="lnt">186
</span><span class="lnt">187
</span><span class="lnt">188
</span><span class="lnt">189
</span><span class="lnt">190
</span><span class="lnt">191
</span><span class="lnt">192
</span><span class="lnt">193
</span><span class="lnt">194
</span><span class="lnt">195
</span><span class="lnt">196
</span><span class="lnt">197
</span><span class="lnt">198
</span><span class="lnt">199
</span><span class="lnt">200
</span><span class="lnt">201
</span><span class="lnt">202
</span><span class="lnt">203
</span><span class="lnt">204
</span><span class="lnt">205
</span><span class="lnt">206
</span><span class="lnt">207
</span><span class="lnt">208
</span><span class="lnt">209
</span><span class="lnt">210
</span><span class="lnt">211
</span><span class="lnt">212
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl">    <span class="cm">/*
</span></span></span><span class="line"><span class="cl"><span class="cm">     * =====================================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     *       Filename:  scull.c
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     *    Description:  this is a first driver from ldd3
</span></span></span><span class="line"><span class="cl"><span class="cm">     *                  ignore mutithread race, data overflow,
</span></span></span><span class="line"><span class="cl"><span class="cm">     *                  just a simple example.
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     *        Version:  1.0
</span></span></span><span class="line"><span class="cl"><span class="cm">     *        Created:  11/29/2014 09:00:04 PM
</span></span></span><span class="line"><span class="cl"><span class="cm">     *       Revision:  none
</span></span></span><span class="line"><span class="cl"><span class="cm">     *       Compiler:  gcc
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     *         Author:  Xu Jianjun(firemiles), 
</span></span></span><span class="line"><span class="cl"><span class="cm">     *   Organization:  
</span></span></span><span class="line"><span class="cl"><span class="cm">     *
</span></span></span><span class="line"><span class="cl"><span class="cm">     * =====================================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="cp">#include</span> <span class="cpf">&lt;linux/module.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp">#include</span> <span class="cpf">&lt;linux/init.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp">#include</span> <span class="cpf">&lt;linux/fs.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp">#include</span> <span class="cpf">&lt;linux/cdev.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp">#include</span> <span class="cpf">&lt;linux/uaccess.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>    <span class="cp">#include</span> <span class="cpf">&lt;linux/slab.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl">    <span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&#34;GPL&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">long</span> <span class="nf">scull_ioctl</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">ssize_t</span> <span class="nf">scull_write</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                            <span class="n">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">f_ops</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">ssize_t</span> <span class="nf">scull_read</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> 
</span></span><span class="line"><span class="cl">                            <span class="n">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">f_ops</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">loff_t</span> <span class="nf">scull_llseek</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">f_ops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="nf">scull_release</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="nf">scull_open</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="n">scull_major</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="n">scull_minor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">scull_dev</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">size_t</span> <span class="n">maxlen</span><span class="p">;</span> <span class="c1">//buffer length
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">size_t</span> <span class="n">len</span><span class="p">;</span>    <span class="c1">//data length
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">struct</span>  <span class="n">cdev</span> <span class="n">cdev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span><span class="n">scull_dev1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">scull_fops</span> <span class="o">=</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">owner</span>  <span class="o">=</span>   <span class="n">THIS_MODULE</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">llseek</span> <span class="o">=</span>   <span class="n">scull_llseek</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">read</span>   <span class="o">=</span>   <span class="n">scull_read</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">write</span>  <span class="o">=</span>   <span class="n">scull_write</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">unlocked_ioctl</span>  <span class="o">=</span>   <span class="n">scull_ioctl</span><span class="p">,</span> <span class="c1">//new api
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="p">.</span><span class="n">open</span>   <span class="o">=</span>   <span class="n">scull_open</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">        <span class="p">.</span><span class="n">release</span><span class="o">=</span>   <span class="n">scull_release</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="p">};</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 
</span></span></span><span class="line"><span class="cl"><span class="cm">     * ===  FUNCTION  ======================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     *         Name:  scull open
</span></span></span><span class="line"><span class="cl"><span class="cm">     *  Description:  
</span></span></span><span class="line"><span class="cl"><span class="cm">     * =====================================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="nf">scull_open</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">scull_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">dev</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_cdev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scull_dev</span><span class="p">,</span> <span class="n">cdev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">dev</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">kmalloc</span><span class="p">(</span><span class="mi">1024</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">dev</span><span class="o">-&gt;</span><span class="n">maxlen</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">            <span class="n">dev</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>       <span class="cm">/* -----  end of function scull open  ----- */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 
</span></span></span><span class="line"><span class="cl"><span class="cm">     * ===  FUNCTION  ======================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     *         Name:  scull_close
</span></span></span><span class="line"><span class="cl"><span class="cm">     *  Description:  
</span></span></span><span class="line"><span class="cl"><span class="cm">     * =====================================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="nf">scull_release</span> <span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>       <span class="cm">/* -----  end of function scull_close  ----- */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 
</span></span></span><span class="line"><span class="cl"><span class="cm">     * ===  FUNCTION  ======================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     *         Name:  scull_llseek
</span></span></span><span class="line"><span class="cl"><span class="cm">     *  Description:  
</span></span></span><span class="line"><span class="cl"><span class="cm">     * =====================================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">loff_t</span> <span class="nf">scull_llseek</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">f_ops</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>       <span class="cm">/* -----  end of function scull_llseek  ----- */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 
</span></span></span><span class="line"><span class="cl"><span class="cm">     * ===  FUNCTION  ======================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     *         Name:  scull_read
</span></span></span><span class="line"><span class="cl"><span class="cm">     *  Description:  
</span></span></span><span class="line"><span class="cl"><span class="cm">     * =====================================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">ssize_t</span> <span class="nf">scull_read</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">f_ops</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">scull_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">copy_to_user</span><span class="p">(</span><span class="n">buff</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span> <span class="c1">// ignore buff overflow;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">num</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">num</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>       <span class="cm">/* -----  end of function scull_read  ----- */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 
</span></span></span><span class="line"><span class="cl"><span class="cm">     * ===  FUNCTION  ======================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     *         Name:  scull_write
</span></span></span><span class="line"><span class="cl"><span class="cm">     *  Description:  
</span></span></span><span class="line"><span class="cl"><span class="cm">     * =====================================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="n">ssize_t</span> <span class="nf">scull_write</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span> <span class="n">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">f_ops</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">struct</span> <span class="n">scull_dev</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">copy_from_user</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">buff</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span> <span class="c1">// ignore data overflow; 
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>       <span class="cm">/* -----  end of function scull_write  ----- */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 
</span></span></span><span class="line"><span class="cl"><span class="cm">     * ===  FUNCTION  ======================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     *         Name:  scull_ioctl
</span></span></span><span class="line"><span class="cl"><span class="cm">     *  Description:  
</span></span></span><span class="line"><span class="cl"><span class="cm">     * =====================================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">long</span> <span class="nf">scull_ioctl</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>       <span class="cm">/* -----  end of function scull_ioctl  ----- */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 
</span></span></span><span class="line"><span class="cl"><span class="cm">     * ===  FUNCTION  ======================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     *         Name:  scull_setup_cdev
</span></span></span><span class="line"><span class="cl"><span class="cm">     *  Description:  
</span></span></span><span class="line"><span class="cl"><span class="cm">     * =====================================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">void</span> <span class="nf">scull_setup_cdev</span> <span class="p">(</span><span class="k">struct</span> <span class="n">scull_dev</span> <span class="o">*</span><span class="n">dev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">dev_t</span> <span class="n">devnum</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">        <span class="n">sprintf</span><span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="s">&#34;scull1&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">scull_major</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">devnum</span> <span class="o">=</span> <span class="n">MKDEV</span><span class="p">(</span><span class="n">scull_major</span><span class="p">,</span> <span class="n">scull_minor</span><span class="o">+</span><span class="n">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">err</span> <span class="o">=</span> <span class="n">register_chrdev_region</span><span class="p">(</span><span class="n">devnum</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span><span class="k">else</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">err</span> <span class="o">=</span> <span class="n">alloc_chrdev_region</span><span class="p">(</span><span class="o">&amp;</span><span class="n">devnum</span><span class="p">,</span> <span class="n">scull_minor</span><span class="o">+</span><span class="n">index</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="n">scull_major</span> <span class="o">=</span> <span class="n">MAJOR</span><span class="p">(</span><span class="n">devnum</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">err</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&#34;scull1: can&#39;t get major %d</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">scull_major</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="k">return</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">cdev_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scull_fops</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">scull_fops</span><span class="p">;</span> <span class="c1">//nessary?
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="n">err</span> <span class="o">=</span> <span class="n">cdev_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">cdev</span><span class="p">,</span> <span class="n">devnum</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">err</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">            <span class="n">printk</span><span class="p">(</span><span class="n">KERN_NOTICE</span> <span class="s">&#34;Error %d adding scull%d&#34;</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>       <span class="cm">/* -----  end of function scull_setup_cdev  ----- */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/*  
</span></span></span><span class="line"><span class="cl"><span class="cm">     * ===  FUNCTION  ======================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     *         Name:  scull_init
</span></span></span><span class="line"><span class="cl"><span class="cm">     *  Description:  
</span></span></span><span class="line"><span class="cl"><span class="cm">     * =====================================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">scull_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">scull_setup_cdev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scull_dev1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&#34;scull init</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>       <span class="cm">/* -----  end of function scull_init  ----- */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="cm">/* 
</span></span></span><span class="line"><span class="cl"><span class="cm">     * ===  FUNCTION  ======================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     *         Name:  scull_exit
</span></span></span><span class="line"><span class="cl"><span class="cm">     *  Description:  
</span></span></span><span class="line"><span class="cl"><span class="cm">     * =====================================================================================
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">    <span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">scull_exit</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">kfree</span><span class="p">(</span><span class="n">scull_dev1</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">unregister_chrdev_region</span><span class="p">(</span><span class="n">scull_dev1</span><span class="p">.</span><span class="n">cdev</span><span class="p">.</span><span class="n">dev</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">cdev_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">scull_dev1</span><span class="p">.</span><span class="n">cdev</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">printk</span><span class="p">(</span><span class="n">KERN_ALERT</span> <span class="s">&#34;scull exit</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>       <span class="cm">/* -----  end of function scull_exit  ----- */</span>
</span></span><span class="line"><span class="cl">    <span class="cm">/* this macro told to compiler.
</span></span></span><span class="line"><span class="cl"><span class="cm">     * that the two function are init function and exit function
</span></span></span><span class="line"><span class="cl"><span class="cm">     * 
</span></span></span><span class="line"><span class="cl"><span class="cm">     */</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="n">module_init</span><span class="p">(</span><span class="n">scull_init</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="n">module_exit</span><span class="p">(</span><span class="n">scull_exit</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div>]]></description></item></channel></rss>